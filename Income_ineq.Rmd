---
title: "Income inequality"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading libraries
You only need to install packages once. You need to call the library every time you reopen. Order matters!
```{r}
#install.packages("tidyverse")
#install.packages("fitdistrplus")
#library(plyr)
#library(ggplot2)
library(DescTools)
library(fitdistrplus)
library(spatstat)
library(tidyverse)

#This was from my course:
#packages <- c("dplyr", "tidyr", "readr", "devtools", "usethis", "roxygen2", "leaflet", "ggplot2", "DT", "scales", "shiny", "sf", "ggmap", #"broom", "captioner", "MASS")

#for (package in packages) { if (!(package %in% installed.packages())) { install.packages(package) } }
#rm(packages) #remove variable from workspace

## Now upgrade any out-of-date packages
#update.packages(ask=FALSE)
```


```{r}

DMUI=function(x,m){ #DMUI is a function with inputs x (HH income) and m (the median)
  dmui_out=m*log(x/m)+m #output is adjusted income adjustment, per TW equation
  dmui_out[which(x<=m)]=x[which(x<=m)] #but we leave all incomes less or equal to the median alone
  return(dmui_out) #the function returns the the adjusted income
}  

```




## Reading in Data

# Derive median value of Income per year from binned data using a lognormal parametric fit
```{r}
#Read in data as a tibble
inc_ineq <- read_csv("Inc_ineq_cleaned_ready.csv",col_types = "dddcdddddd") 
#Set "infinite" upper bound at 1,000,000 and make sure data types are numeric
inc_ineq$Bracket_max[which(inc_ineq$Bracket_max=="Inf")]=1000000
inc_ineq$Bracket_max=as.numeric(inc_ineq$Bracket_max)
#For Plotting calculated bin width and midpoint
inc_ineq$Bracket_width=inc_ineq$Bracket_max-inc_ineq$Bracket_min
inc_ineq$Bracket_mid=(inc_ineq$Bracket_max+inc_ineq$Bracket_min)/2
plot(subset(inc_ineq,Num_returns>0)$Bracket_mid,subset(inc_ineq,Num_returns>0)$AGI_bin_mean)
#Restrict only to necessary columns
#iibins=as.data.frame(inc_ineq[,c("Year","Bracket_min","Bracket_max","Num_returns")])

#For each target year (omit no data years - throws error)
#omit years with all zeros
#Nyr=ddply(inc_ineq,.(Year),summarize,S=sum(Num_returns))
Nyr <- inc_ineq %>% 
  group_by(Year) %>%
  summarize(S=sum(Num_returns)) %>%
  filter(S>0) 
uY=Nyr$Year

############ Kludgy Case Diminish by bin

#Calculate median from AGI_bin_mean centers and Num_factors (weighted median)
Y_med <- inc_ineq %>%
  filter(Year %in% uY) %>% 
  group_by(Year) %>% 
  summarise(Median=weighted.median(x = AGI_bin_mean,w = Num_returns))

inc_ineq$AGI_bin_mean_DMUI=DMUI(x = inc_ineq$AGI_bin_mean,m=Y_med$Median[match(inc_ineq$Year,Y_med$Year)])
View(inc_ineq)

#Generate "integrals"
Ysum <- inc_ineq %>% 
  group_by(Year) %>% 
  summarize(AGI_ann=sum(AGI_USD_all),AGI_ann2=sum(AGI_bin_mean*Num_returns),AGI_annDMUI=sum(AGI_bin_mean_DMUI*Num_returns))
#generate ratios of undiscounted and discounted integrals
Ysum$DMUI_Ratio=Ysum$AGI_annDMUI/Ysum$AGI_ann
plot(Ysum$Year,Ysum$DMUI_Ratio)

ggplot(inc_ineq)+
  geom_point(aes(AGI_bin_mean_DMUI,Num_returns),color="blue")+
  geom_path(aes(AGI_bin_mean_DMUI,Num_returns),color="blue")+
  geom_point(aes(AGI_bin_mean,Num_returns))+
  geom_path(aes(AGI_bin_mean,Num_returns))+
  facet_wrap("Year")+
  scale_x_log10()+
  geom_vline(data=Y_med,aes(xintercept=Median))



#In case Num_returns will generate too large of a data structure
# set a multiplicative factor to divide by. i.e. 1 = no reduction
reduce_factor=1
iibins$Nrep=floor(iibins$Num_returns/reduce_factor)

#Generate a row-by-row data frame to showcase each return for use in "fitdistcens" function
iiyr=iibins %>%
  uncount(weights = Nrep)
#rename columns for fitdiscens
names(iiyr)[c(2,3)]=c("left","right")

#uY=c(2000:2006,2012:2018) #can change this to 1960
#Set up summary output dataframe
Yout=data.frame(Year=uY,meanlog=NA,sdlog=NA,median=NA)


# This is where we set ourselves up to be able to generate a distribution curve for each year

#loop over each year in target list
for(i_y in 1:length(uY)){
  #subset to single year
  thisy=subset(iiyr,Year==uY[i_y])
  
  ################
  # Core function "disty" - fit the year's data into parametric lognormal distribution
  ################
  
  #fitdistcens function fits univariate distribution to "censored" (binned) data
  disty=fitdistcens(censdata = thisy,distr = "lnorm",start = list(meanlog=10,sdlog=1))
  
  #Pull data from distribution output into output dataframe to record mean, log, median of each year's dist
  Yout$meanlog[i_y]=disty$estimate[1]
  Yout$sdlog[i_y]=disty$estimate[2]
  Yout$median[i_y]=exp(disty$estimate[1])
  
  #Output progress information
  print(paste0(uY[i_y]," done. ",i_y,"th year of ",length(uY)))
  print(Yout[1:i_y,])
}
#The function ends

#Show off final summary data
Yout

#Prep for plot
#Set up parametric density curve data frame for plotting (not core to functionality)
xr=seq(0,1e6,length.out=1e3+1)
 
paramcurves=expand.grid(x=xr,y=NA,Year=Yout$Year)
  #Generate and bind the density curve for plotting
for(i_y in 1:nrow(Yout)){
  thisyr_i=which(paramcurves$Year==Yout$Year[i_y])
  paramcurves$y[thisyr_i]=dlnorm(x=xr,meanlog=Yout$meanlog[i_y],sdlog = Yout$sdlog[i_y])
}

#Bad style
# #paramcurves=NULL
#   #Generate and bind the density curve for plotting
# for(i_y in 1:nrow(Yout)){
#   paramcurves=rbind(paramcurves,
#                     data.frame(
#                       Year=Yout$Year[i_y],
#                       x=xr,
#                       y=dlnorm(x=xr,meanlog=Yout$meanlog[i_y],sdlog = Yout$sdlog[i_y])))
# }

inc_ineq$count_dens=inc_ineq$Num_returns/(3*inc_ineq$Bracket_width*max(inc_ineq$Num_returns))
#plot
lnormfits_plot=ggplot(subset(inc_ineq,Year%in%uY),aes(x=Bracket_mid,y=count_dens))+
  geom_col(aes(width=Bracket_width),position="identity",color="black",fill="gray75")+
  geom_path(data=paramcurves,aes(x=x,y=y),color="green")+
  geom_vline(aes(xintercept = median),data=Yout,color="darkred")+
  geom_text(aes(x=median*3,y=2e-5,label=round(median,2)),data=Yout)+
  facet_wrap("Year")+xlim(c(0,500000))+
  theme_bw()

#show plot
lnormfits_plot

#save plot
ggsave(plot=lnormfits_plot,filename="LogNormalAnnualIncomeFits.jpg")

#save summary Data
write.csv(Yout,"LogNormFits.csv")
#Yout=read.csv("LogNormFits.csv")
```

# DMUI adjustment

## Talberth and Weisdorf
Talberth and Weisdorf's equation is for median-income normalized logarithmic DMUI adjustment:
adj(x_, m_) := m log(x/m) + m
where x is household income, m is median income, and log is the natural logarithm.

```{r}
# Just building intuition, creating a random sequence, setting a median, and plotting
x=seq(0,500000,length.out=1000)
m=33145
plot(x,m*log(x/m)+m,xlim=c(0,500000),ylim=c(0,500000))
abline(v=m)
abline(0,1)

  ################
  # Function to calculate the adjusted income
  # (This is the real stuff)
  ################

# Our dataframe paramcurves gets a new column, which is calculated by the function DMUI, given the median of that year
# Note that the match calls on two different dataframes, paramcurves and Yout, matching by year - super useful!
paramcurves$xadj=DMUI(paramcurves$x,m = Yout$median[match(paramcurves$Year,Yout$Year)])
#generate count-like data from these density curves
ymax=max(paramcurves$y[paramcurves$y>0])
ymin=min(paramcurves$y[paramcurves$y>0])
hist(log10(paramcurves$y))
paramcurves$ycount=round(1e9*paramcurves$y,0)
plot(paramcurves$x,paramcurves$ycount,cex=.1)
# Note:
#.(Year) groups by year in ddply - in tidyverse you would pipe to group by year; select function - look this up
# ddply is old school; in tidyverse use plyr. It is a split-apply-combine paradigm 

# So here we split paramcurves, grouped by year, and summarize:
# MaxX as the max of the adjusted x
# Yinc as the sum of the values of income up to MaxX
# Yadj as the sum of the values of adjusted income up to MaxX
# Note you need to put a limit on the integral, otherwise both adjusted and normal would be 1
xa=ddply(paramcurves,.(Year),summarize,
         MaxX=500000,#max(xadj),
         Yinc=sum(x[which(x<MaxX)]*y[which(x<MaxX)]),
         Yadj=sum(xadj[which(xadj<MaxX)]*y[which(xadj<MaxX)]))

# We then calculate the ratio of the unadjusted to adjusted
xa$ratio=xa$Yadj/xa$Yinc
xa$logratio=log2(xa$Yadj/xa$Yinc)
xa
#Plot the ratio
ggplot(xa,aes(Year,ratio))+geom_point()

#Plot the distributions (original in green and adjusted in blue) and the median
ggplot(subset(paramcurves,x<500000),aes(y=y))+
  geom_path(aes(x=x),color="green")+
  geom_path(aes(x=xadj),color="blue")+
  geom_vline(data=Yout,aes(xintercept=median))+
  facet_wrap("Year")+xlim(c(0,500000))

#calculate the GINI to test
install.packages("DescTools")
library(DescTools)

#Gini(x, n=(1, length(x)), unbiased = TRUE, conf.level = NA, R = 1000, type = "bca", na.rm = FALSE)
Gini_pc <- paramcurves %>%
  group_by(Year) %>% 
  summarise(G=Gini(x=x, n=ycount,na.rm=T))
Gini_pc  

Gini_ii <- inc_ineq %>%
  group_by(Year) %>% 
  summarise(G=Gini(x=Bracket_mid, n=Num_returns,na.rm=T))
Gini_ii  

Gini_iiagi <- inc_ineq %>%
  group_by(Year) %>% 
  summarise(G=Gini(x=AGI_bin_mean, n=Num_returns,na.rm=T))
Gini_iiagi  

gii=ggplot(Gini_ii,  
       aes(Year,G)) + 
  geom_point()+geom_path()

giia=ggplot(Gini_iiagi,  
       aes(Year,G)) + 
  geom_point()+geom_path()

gpc=ggplot(Gini_pc,  
       aes(Year,G)) + 
  geom_point()+geom_path()

library(patchwork)
giia+gii+gpc

Gini_pcdd=ddply(paramcurves,.(Year),summarize,
                G=Gini(x=x, n=10^6*y,na.rm=T))

x18=subset(paramcurves,Year==2018)
Gini(x18$x,x18$y,na.rm=T)

Gini(0:100,rep(1,101))

```



## Weisdorf
```{r}
suff_th <- read_csv("Suff_thresh_INQ.csv")#),col_types = "dddddddd") 
```



